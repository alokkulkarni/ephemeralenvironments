# This workflow handles both validation and deployment of Terraform environments
# It validates tfvars on PR creation/update and immediately deploys the environment

name: terraform-environment-workflow

on:
  pull_request:
    branches:
      - main
      - master
      - develop
    paths:
      - 'aws/terraform.tfvars'

jobs:
  create-issue:
    name: Create Environment Issue
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    outputs:
      issue_number: ${{ steps.create_issue.outputs.issue_number }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read tfvars file
        id: tfvars
        run: |
          if [ ! -f aws/terraform.tfvars ]; then
            echo "Error: terraform.tfvars file not found"
            exit 1
          fi
          
          # Read project information
          PROJECT_NAME=$(grep -Po 'project_name\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          ORG_NAME=$(grep -Po 'org_name\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          SQUAD_NAME=$(grep -Po 'squad_name\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          ENVIRONMENT=$(grep -Po 'environment\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "org_name=$ORG_NAME" >> $GITHUB_OUTPUT
          echo "squad_name=$SQUAD_NAME" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

      - name: Create Environment Issue
        id: create_issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const projectName = '${{ steps.tfvars.outputs.project_name }}';
            const orgName = '${{ steps.tfvars.outputs.org_name }}';
            const squadName = '${{ steps.tfvars.outputs.squad_name }}';
            const environment = '${{ steps.tfvars.outputs.environment }}';
            const prNumber = context.issue.number;
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[ENV] Create Environment: ${projectName}-${environment}`,
              body: `## Environment Creation Started 🚀
              
              Creating a new environment with the following details:
              
              - Project: ${projectName}
              - Organization: ${orgName}
              - Squad: ${squadName}
              - Environment: ${environment}
              - PR: #${prNumber}
              
              ### Status
              - [ ] Validate tfvars file
              - [ ] Create environment directory
              - [ ] Initialize Terraform
              - [ ] Plan infrastructure
              - [ ] Apply infrastructure
              - [ ] Upload artifacts
              
              ### Files
              - \`terraform.tfvars\`: Environment variables (to be attached)
              - \`plan.out\`: Terraform plan output (to be attached)
              - \`logs/\`: Directory containing execution logs (to be attached)
              
              Created from PR #${prNumber}
              
              \`\`\`json
              {
                "environment": {
                  "project": "${projectName}",
                  "organization": "${orgName}",
                  "squad": "${squadName}",
                  "type": "${environment}",
                  "created_at": "${new Date().toISOString()}",
                  "pr_number": ${prNumber},
                  "status": "creating"
                }
              }
              \`\`\`
              `,
              labels: ['environment', 'status:creating']
            });
            
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Environment Creation Started 🚀
              
              An issue has been created to track the environment creation process.
              
              See issue #${issue.data.number}: [Create Environment: ${projectName}-${environment}](${issue.data.html_url})
              `
            });
            
            core.setOutput('issue_number', issue.data.number);

  validate-and-deploy:
    name: Validate and Deploy Environment
    needs: create-issue
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      TF_IN_AUTOMATION: true
      AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0
          terraform_wrapper: false

      - name: Update Issue Status - Validating
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const updatedBody = issue.data.body.replace('- [ ] Validate tfvars file', '- [x] Validate tfvars file');
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody
            });

      - name: Validate tfvars file
        id: validate
        run: |
          # Check if tfvars file exists
          if [ ! -f aws/terraform.tfvars ]; then
            echo "Error: terraform.tfvars file not found"
            exit 1
          fi

          # Validate required variables
          required_vars=(
            "environment"
            "aws_region"
            "project_name"
            "org_name"
            "squad_name"
            "enable_rds"
            "enable_dynamodb"
            "enable_s3"
            "enable_elasticache"
          )

          for var in "${required_vars[@]}"; do
            if ! grep -q "^$var" aws/terraform.tfvars; then
              echo "Error: Required variable '$var' not found in terraform.tfvars"
              exit 1
            fi
          done

          # Validate environment value
          if ! grep -qP 'environment\s*=\s*"(dev|staging|prod)"' aws/terraform.tfvars; then
            echo "Error: Invalid environment value in terraform.tfvars"
            exit 1
          fi

          # Validate AWS region
          if ! grep -qP 'aws_region\s*=\s*"(us-east-1|us-west-2|eu-west-1|eu-west-2|ap-southeast-1)"' aws/terraform.tfvars; then
            echo "Error: Invalid AWS region in terraform.tfvars"
            exit 1
          fi

          # Read project information for later use
          PROJECT_NAME=$(grep -Po 'project_name\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          ORG_NAME=$(grep -Po 'org_name\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          SQUAD_NAME=$(grep -Po 'squad_name\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          ENVIRONMENT=$(grep -Po 'environment\s*=\s*"\K[^"]*' aws/terraform.tfvars)
          
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "org_name=$ORG_NAME" >> $GITHUB_OUTPUT
          echo "squad_name=$SQUAD_NAME" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

          # Update issue with validation results
          echo "validation_success=true" >> $GITHUB_OUTPUT

      - name: Update Issue Status - Creating Directory
        if: steps.validate.outputs.validation_success == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const updatedBody = issue.data.body.replace('- [ ] Create environment directory', '- [x] Create environment directory');
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody
            });

      - name: Create environments directory
        id: env_dir
        run: |
          TIMESTAMP=$(date +"%Y%m%d%H%M%S")
          ENV_DIR="environments/${{ steps.validate.outputs.project_name }}-${{ steps.validate.outputs.org_name }}-${{ steps.validate.outputs.squad_name }}-${{ steps.validate.outputs.environment }}-${TIMESTAMP}"
          mkdir -p "$ENV_DIR"
          echo "env_dir=$ENV_DIR" >> $GITHUB_OUTPUT
          echo "ENV_DIR=$ENV_DIR" >> $GITHUB_ENV

      - name: Setup environment directory
        run: |
          # Create necessary subdirectories
          mkdir -p "${{ env.ENV_DIR }}/.terraform"
          mkdir -p "${{ env.ENV_DIR }}/logs"
          
          # Copy all Terraform files to the environment directory
          cp -r aws/* "${{ env.ENV_DIR }}/"
          
          # Verify tfvars file was copied correctly
          if [ ! -f "${{ env.ENV_DIR }}/terraform.tfvars" ]; then
            echo "Error: terraform.tfvars not found in environment directory"
            exit 1
          fi
          
          # Create backend configuration
          cat > "${{ env.ENV_DIR }}/backend.tf" <<EOF
          terraform {
            backend "local" {
              path = "terraform.tfstate"
            }
          }
          EOF
          
          # Create a README with environment details
          cat > "${{ env.ENV_DIR }}/README.md" <<EOF
          # Environment: ${{ steps.validate.outputs.project_name }}-${{ steps.validate.outputs.environment }}
          
          Created: $(date)
          Project: ${{ steps.validate.outputs.project_name }}
          Organization: ${{ steps.validate.outputs.org_name }}
          Squad: ${{ steps.validate.outputs.squad_name }}
          Environment: ${{ steps.validate.outputs.environment }}
          
          ## Files
          - \`terraform.tfvars\`: Environment variables
          - \`terraform.tfstate\`: Terraform state file
          - \`plan.out\`: Terraform plan output
          - \`logs/\`: Directory containing execution logs
          
          ## Logs
          - \`logs/init.log\`: Terraform initialization logs
          - \`logs/plan.log\`: Terraform plan logs
          - \`logs/apply.log\`: Terraform apply logs
          EOF
          
          # List contents of environment directory for verification
          echo "Contents of environment directory:"
          ls -la "${{ env.ENV_DIR }}"

          # Attach tfvars file to issue
          echo "TFVARS_PATH=${{ env.ENV_DIR }}/terraform.tfvars" >> $GITHUB_ENV

      - name: Attach tfvars file to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require('fs');
              const tfvarsContent = fs.readFileSync(process.env.TFVARS_PATH, 'utf8');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }},
                body: `## Terraform Variables File
                
                \`\`\`hcl
                ${tfvarsContent}
                \`\`\`
                `
              });
            } catch (error) {
              console.error('Error attaching tfvars file:', error);
            }

      - name: Update Issue Status - Initializing
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const updatedBody = issue.data.body.replace('- [ ] Initialize Terraform', '- [x] Initialize Terraform');
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody
            });

      - name: Terraform Init
        id: init
        working-directory: ${{ env.ENV_DIR }}
        continue-on-error: false
        run: |
          # Verify tfvars file exists before init
          if [ ! -f "terraform.tfvars" ]; then
            echo "Error: terraform.tfvars not found in working directory"
            exit 1
          fi
          
          # Initialize Terraform
          terraform init -upgrade -reconfigure | tee logs/init.log
          
          # Check init status
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Error: Terraform init failed"
            exit 1
          fi
          
          # Attach init logs to issue
          echo "INIT_LOG_PATH=${{ env.ENV_DIR }}/logs/init.log" >> $GITHUB_ENV

      - name: Attach init logs to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require('fs');
              const initLogContent = fs.readFileSync(process.env.INIT_LOG_PATH, 'utf8');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }},
                body: `## Terraform Initialization Logs
                
                \`\`\`
                ${initLogContent}
                \`\`\`
                `
              });
            } catch (error) {
              console.error('Error attaching init logs:', error);
            }

      - name: Update Issue Status - Planning
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const updatedBody = issue.data.body.replace('- [ ] Plan infrastructure', '- [x] Plan infrastructure');
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody
            });

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.ENV_DIR }}
        continue-on-error: false
        run: |
          # Verify tfvars file exists before plan
          if [ ! -f "terraform.tfvars" ]; then
            echo "Error: terraform.tfvars not found in working directory"
            exit 1
          fi
          
          # Run terraform plan
          terraform plan \
            -var-file="./terraform.tfvars" \
            -out="plan.out" \
            -parallelism=10 \
            -refresh=true \
            | tee logs/plan.log
          
          # Check plan status
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Error: Terraform plan failed"
            exit 1
          fi
          
          # Verify plan output was created
          if [ ! -f "plan.out" ]; then
            echo "Error: terraform plan output file not created"
            exit 1
          fi
          
          # Attach plan logs to issue
          echo "PLAN_LOG_PATH=${{ env.ENV_DIR }}/logs/plan.log" >> $GITHUB_ENV

      - name: Attach plan logs to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require('fs');
              const planLogContent = fs.readFileSync(process.env.PLAN_LOG_PATH, 'utf8');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }},
                body: `## Terraform Plan Logs
                
                \`\`\`
                ${planLogContent}
                \`\`\`
                `
              });
            } catch (error) {
              console.error('Error attaching plan logs:', error);
            }

      - name: Update Issue Status - Applying
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const updatedBody = issue.data.body.replace('- [ ] Apply infrastructure', '- [x] Apply infrastructure');
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody
            });

      - name: Terraform Apply
        id: apply
        working-directory: ${{ env.ENV_DIR }}
        continue-on-error: false
        run: |
          # Verify tfvars file exists before apply
          if [ ! -f "terraform.tfvars" ]; then
            echo "Error: terraform.tfvars not found in working directory"
            exit 1
          fi
          
          # Verify plan output exists
          if [ ! -f "plan.out" ]; then
            echo "Error: terraform plan output file not found"
            exit 1
          fi
          
          # Run terraform apply
          terraform apply \
            -auto-approve \
            "plan.out" \
            | tee logs/apply.log
          
          # Check apply status
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Error: Terraform apply failed"
            exit 1
          fi
          
          # Attach apply logs to issue
          echo "APPLY_LOG_PATH=${{ env.ENV_DIR }}/logs/apply.log" >> $GITHUB_ENV

      - name: Attach apply logs to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require('fs');
              const applyLogContent = fs.readFileSync(process.env.APPLY_LOG_PATH, 'utf8');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }},
                body: `## Terraform Apply Logs
                
                \`\`\`
                ${applyLogContent}
                \`\`\`
                `
              });
            } catch (error) {
              console.error('Error attaching apply logs:', error);
            }

      - name: Upload environment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: environment-${{ github.head_ref }}
          path: ${{ env.ENV_DIR }}
          retention-days: 30

      - name: Create environment zip file
        run: |
          cd "${{ env.ENV_DIR }}"
          zip -r "../environment.zip" .
          cd ..
          echo "ZIP_PATH=${{ env.ENV_DIR }}/../environment.zip" >> $GITHUB_ENV

      - name: Attach environment zip to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require('fs');
              const zipPath = process.env.ZIP_PATH;
              const zipContent = fs.readFileSync(zipPath);
              
              // Create a release asset
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: `env-${context.issue.number}`,
                name: `Environment ${context.issue.number}`,
                body: `Environment files for issue #${context.issue.number}`,
                draft: false,
                prerelease: false
              });
              
              // Upload the zip file as a release asset
              const asset = await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: 'environment.zip',
                data: zipContent,
                headers: {
                  'content-type': 'application/zip'
                }
              });
              
              // Get the download URL from the uploaded asset
              let downloadUrl = '';
              
              // First try to get it directly from the asset response
              if (asset.data && asset.data.browser_download_url) {
                downloadUrl = asset.data.browser_download_url;
              } else {
                // If not available, fetch the release again to get the updated assets
                const updatedRelease = await github.rest.repos.getRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.data.id
                });
                
                // Find our asset in the release
                const envAsset = updatedRelease.data.assets.find(a => a.name === 'environment.zip');
                if (envAsset && envAsset.browser_download_url) {
                  downloadUrl = envAsset.browser_download_url;
                } else {
                  // Still not found, use a generic URL as fallback
                  downloadUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/env-${context.issue.number}`;
                }
              }
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }},
                body: `## Environment Files 📦\n\nEnvironment files are available for download:\n\n[Download Environment Files](${downloadUrl})\n\nThis zip file contains all the necessary files to manage this environment, including:\n- Terraform configuration files\n- Variable files\n- State files\n- Logs\n\nKeep this file safe as it will be needed for environment destruction.`
              });
              
              // Update metadata to include download URL
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }}
              });
              
              const jsonMatch = issue.data.body.match(/```json\n([\s\S]*?)\n```/);
              if (jsonMatch && jsonMatch[1]) {
                const metadata = JSON.parse(jsonMatch[1]);
                metadata.environment.download_url = downloadUrl;
                
                const updatedBody = issue.data.body.replace(
                  /```json\n[\s\S]*?\n```/,
                  `\`\`\`json\n${JSON.stringify(metadata, null, 2)}\n\`\`\``
                );
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: ${{ needs.create-issue.outputs.issue_number }},
                  body: updatedBody
                });
              }
            } catch (error) {
              console.error('Error attaching environment zip:', error);
              
              // Log detailed information about the error
              if (error.response) {
                console.error(`GitHub API Error: ${error.response.status} - ${error.response.data.message}`);
              }
              
              // Add a comment to the issue about the failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.create-issue.outputs.issue_number }},
                body: `## Warning: Environment Files ⚠️\n\nThere was an issue attaching the environment zip file to this issue. The environment was created successfully, but you'll need to download the artifacts from the GitHub Actions run.\n\nError details: ${error.message}`
              });
              
              // Don't fail the whole workflow for this non-critical step
              console.log('Continuing despite zip attachment error');
            }

      - name: Update Issue Status - Complete
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            const envDir = '${{ env.ENV_DIR }}';
            const projectName = '${{ steps.validate.outputs.project_name }}';
            const orgName = '${{ steps.validate.outputs.org_name }}';
            const squadName = '${{ steps.validate.outputs.squad_name }}';
            const environment = '${{ steps.validate.outputs.environment }}';
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const metadata = {
              environment: {
                directory: envDir,
                project: projectName,
                organization: orgName,
                squad: squadName,
                type: environment,
                created_at: new Date().toISOString(),
                pr_number: context.issue.number,
                status: 'active'
              }
            };
            
            let updatedBody = issue.data.body
              .replace('- [ ] Upload artifacts', '- [x] Upload artifacts')
              .replace('status: "creating"', 'status: "active"');
            
            const jsonRegex = /```json\n[\s\S]*?\n```/;
            updatedBody = updatedBody.replace(jsonRegex, `\`\`\`json\n${JSON.stringify(metadata, null, 2)}\n\`\`\``);
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody,
              labels: ['environment', 'status:active']
            });

      - name: Update Issue Status - Failed
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = ${{ needs.create-issue.outputs.issue_number }};
            const failedStep = process.env.FAILED_STEP || 'unknown';
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            let currentMetadata = { environment: {} };
            try {
              const jsonMatch = issue.data.body.match(/```json\n([\s\S]*?)\n```/);
              if (jsonMatch && jsonMatch[1]) {
                currentMetadata = JSON.parse(jsonMatch[1]);
              }
            } catch (parseError) {
              console.error('Error parsing JSON metadata:', parseError);
            }
            
            const updatedMetadata = {
              environment: {
                ...currentMetadata.environment,
                status: 'failed',
                failed_at: new Date().toISOString(),
                failed_step: failedStep
              }
            };
            
            let updatedBody = issue.data.body
              .replace('status: "creating"', 'status: "failed"')
              .replace('status: "active"', 'status: "failed"');
            
            const jsonRegex = /```json\n[\s\S]*?\n```/;
            updatedBody = updatedBody.replace(jsonRegex, `\`\`\`json\n${JSON.stringify(updatedMetadata, null, 2)}\n\`\`\``);
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: updatedBody,
              labels: ['environment', 'status:failed']
            });
            
            // Add failure comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `## Environment Creation Failed ❌\n\nFailed during step: ${failedStep}\n\nPlease check the logs for more details.`
            });